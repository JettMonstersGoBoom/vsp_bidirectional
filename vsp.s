
// heavily based on Shallan's VSP code 
//	major differences 
//	scrolling left & right 
//	colour shift code is generated by code vs the assembler 

* = $02 virtual
	mappos: .byte $00
	VSP_offset: .byte $00
	VSP_offset_old:	.byte $00
	pixel_xscroll: .byte $00
	pixel_speed: .byte $00
	VIC_buffer: .byte $00
	triggerColourShift: .byte $00
	timer: .byte $00
	edgeToUpdate:	.byte 0
	
	asmdest:	.word 0
	source:		.word 0 
	dest:			.word 0 
	cdest:		.word 0 

//	max speeds 
//	anything above 8 will break ( probably )
.label maxspeed = 7
.label negspeed = -7

//	vic screen locations
.label PAGE0_LOCATION = $4000
.label PAGE1_LOCATION = $4400

//	memory addresses for color shift generation 
.label ShiftColorRamR = $7000
.label ShiftColorRamL = ShiftColorRamR+$1800

	#import "modules/c64.s"

BasicUpstart2(Entry)


Entry:
		sei
		//Disable CIA interrupts
		lda #$7f
		sta CIA1.irq_ctrl
		sta CIA2.irq_ctrl

		//Enable Raster Interrupts
		lda #$01
		sta VIC.irq_enable

		//set IRQ
		lda #<IRQ
		ldx #>IRQ
		sta $fffe
		stx $ffff

		//Set line
		lda VIC.cr1
		and #$7f
		sta VIC.cr1
		lda #IRQLine
		sta VIC.raster

		//Bank out kernel and basic
		lda #$35
		sta $01

		//VIC Bank setup
		lda #$02
		sta CIA2.pra //Vic bank 2
		lda #$02 //Screen at $4000, chars at $4800
		sta VIC.mem

		lda #$d0
		sta VIC.cr2	//38 columns, mc mode

		//Set colors
		lda #$00
		sta VIC.border
		sta VIC.bg_color0
		lda #$9
		sta VIC.bg_color1
		lda #$0c
		sta VIC.bg_color2


		jsr ScrollBuild


		//ack interrupt
		asl VIC.irq

		cli



		//Reset variables
		lda #$00
		sta VSP_offset
		sta mappos
		sta VIC_buffer
		sta triggerColourShift
		lda #$07
		sta pixel_xscroll
		lda #$fe
		sta pixel_speed

		//Initialise map
		jsr copyInitialScreen

	!Loop:
		lda triggerColourShift
		cmp #$01	//Only shift color when needed and after all other map update is done
		bne !Loop-
		lda #$00
		sta triggerColourShift
		inc VIC.border

		jsr ColorShift:ShiftColorRamR

		dec VIC.border 

		jmp !Loop-


copyInitialScreen: {
		//Copy first full screen of map, including colors
		ldx #39
	!:
		.for(var i=0; i<24; i++) {
			lda MAP + i * $100, x
			sta PAGE0_LOCATION + i * $28, x
			tay
			lda COLORS, y
			sta $d800 + i * $28, x
		}
		dex
		bmi !+
		jmp !-
	!:


		//Ensure last line of screen is black to hide garbage
		ldx #39
		lda #$00
	!:
		sta $d800 + 24 * 40, x
		dex
		bpl !-
		rts
}


UpdateScroll: {
		//Apply the pixel_xscroll value 
		lda VIC.cr2
		and #$f8
		ora pixel_xscroll
		sta VIC.cr2
		rts
}






.label IRQLine = $2f
IRQ:
		//save state
		pha
		txa 
		pha 
		tya 
		pha 

		lda #$1b
		sta VIC.cr1

		lda #<StableIRQ
		ldx #>StableIRQ
		sta $fffe
		stx $ffff
		inc VIC.raster
		asl VIC.irq

		tsx
		cli

		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		
		



.align $100
StableIRQ:
		// 0-1 cycles of jitter here now
		txs   

		ldx #$07  //X * 5 + 1
	!:
		dex
		bne !-	
		nop
		nop
		nop
		clv


		//Force a branch if 0 jitter and not if 1 jitter
		//causing either 3 or 2 cycles to be added
		lda VIC.raster
		cmp VIC.raster
		beq !+
	!:

		//Raster is stable here!


		//Waste more cycles
		ldx #$0a
	!:
		dex
		bne !-
		nop
		nop

		//Waste an exact number of cycles + VSP_offset
		lda VSP_offset
		lsr
		sta selfmod_branch + 1
		bcc !+ //2 cycles if VSP_offset was odd, 3 if even
	!:
	selfmod_branch:
		bvc *  //relative becomes VSP_offset /2

		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop

		dec VIC.cr1
		inc VIC.cr1

		//Ack interrupt
		asl VIC.irq

		//Point back to original IRQ
		lda #<ShiftIRQ
		ldx #>ShiftIRQ
		sta $fffe
		stx $ffff
		lda #$f1
		sta VIC.raster

		//restore state
		pla
		tay 
		pla  
		tax 
		pla 
		rti


ShiftIRQ:
		//save state
		pha
		txa 
		pha 
		tya 
		pha 


		//Wait for next line and force invalid vic display mode
		//to hide the glitch at the bottom of thje screen
		lda VIC.raster
		cmp VIC.raster
		beq *-3
		lda #$7b
		sta VIC.cr1

		inc VIC.border


	//JOYSTICK SPEED CONTROLS
		inc timer
		lda timer
		and #$07
		bne !+
		lda $dc00
		lsr
		lsr
	!CheckLeft:
		lsr
		bcs !CheckRight+
		ldx pixel_speed
		cpx #negspeed
		beq !CheckDone+
		dec pixel_speed

	!CheckRight:
		lsr
		bcs !CheckDone+
		ldx pixel_speed
		cpx #maxspeed
		beq !CheckDone+
		inc pixel_speed
	!CheckDone:
	!:


		lda VSP_offset
		sta VSP_offset_old


		lda pixel_speed
		bne shouldscroll
		jmp out 
	shouldscroll:
		bpl scrollright
		scrollleft:
		{
			lda #<updateEdge.Left
			sta edgeUpdate
			lda #>updateEdge.Left
			sta edgeUpdate+1

			lda #00
			sta edgeToUpdate
			sec
			lda pixel_xscroll
			sbc pixel_speed
			sta pixel_xscroll
			cmp #$8
			bmi noup
			sec 
			sbc #8 
			sta pixel_xscroll

			sec 
			lda VSP_offset
			sbc #1 
			cmp #$ff 
			bne noreset
			lda #<ShiftColorRamL
			sta ColorShift
			lda #>ShiftColorRamL
			sta ColorShift+1

			lda #$01
			sta triggerColourShift

			sec 
			lda mappos
			sbc #40 
			sta mappos
			lda VIC_buffer
			eor #$01
			sta VIC_buffer

			lda #39
		noreset:
			sta VSP_offset
		noup:
		}

		jmp out

		scrollright:
		{
			lda #<updateEdge.Right
			sta edgeUpdate
			lda #>updateEdge.Right
			sta edgeUpdate+1

			lda #39
			sta edgeToUpdate
			sec
			lda pixel_xscroll
			sbc pixel_speed
			sta pixel_xscroll
			bpl noup
			clc 
			adc #8 
			sta pixel_xscroll

			clc 
			lda VSP_offset
			adc #1 
			cmp #40 
			bne noreset


			lda #$01
			sta triggerColourShift


			lda #<ShiftColorRamR
			sta ColorShift
			lda #>ShiftColorRamR
			sta ColorShift+1

			clc 
			lda mappos
			adc #40 
			sta mappos
			lda VIC_buffer
			eor #$01
			sta VIC_buffer
			lda #$00 
		noreset:
			sta VSP_offset

		noup:
		}

		out:

		ldy VSP_offset
		cpy VSP_offset_old
		beq noedge
		tya
		clc 
		adc mappos
		adc edgeToUpdate
		tax
		jsr edgeUpdate:$0000		
	noedge:



		jsr UpdateScroll




	


		//Point back to original IRQ
		lda #<IRQ
		ldx #>IRQ
		sta $fffe
		stx $ffff
		lda #IRQLine
		sta VIC.raster


		asl VIC.irq

		dec VIC.border
		//restore state
		pla
		tay 
		pla  
		tax 
		pla 
		rti




updateEdge:
{

Right:
		lda VIC_buffer
		asl
		asl
		asl
		asl
		ora #$02
		sta $d018
	
		lda VIC_buffer
		beq buffer1
		jmp buffer2

buffer1:
	//Map Column copy
		.for(var i=0; i<24; i++) {
			//Copy nex t column from map
			lda MAP + i * $100, x
			//To relevant column on screen (back 1 char and down q1 char)
			sta PAGE0_LOCATION + $28 + i * $28 - 1, y
			//Also to other VIC_buffer
			sta PAGE1_LOCATION + i * $28 - 1,y
		}
		//set column colors
		.for(var i=0; i<24; i++) {
			lda PAGE0_LOCATION + $28 + i * $28 - 1, y
			tax
			lda COLORS, x
			sta $d828 + i * $28 - 1, y
		}
		rts
buffer2:

	//Map Column copy
		.for(var i=0; i<24; i++) {
			//Copy nex t column from map
			lda MAP + i * $100, x
			//To relevant column on screen (back 1 char and down q1 char)
			sta PAGE1_LOCATION + $0028 + i * $28 - 1, y
			//Also to other VIC_buffer
			sta PAGE0_LOCATION + i * $28 - 1,y
		}
		//set column colors
		.for(var i=0; i<24; i++) {
			lda PAGE1_LOCATION + $0028 + i * $28 - 1, y
			tax
			lda COLORS, x
			sta $d828 + i * $28 - 1, y
		}
		rts	

Left:
		lda VIC_buffer
		asl
		asl
		asl
		asl
		ora #$02
		sta $d018
	
		lda VIC_buffer
		beq lbuffer1
		jmp lbuffer2

lbuffer1:
	//Map Column copy
		.for(var i=0; i<24; i++) {
			//Copy nex t column from map
			lda MAP + i * $100, x
			//To relevant column on screen (back 1 char and down q1 char)
			sta PAGE0_LOCATION + i * $28 , y
			//Also to other VIC_buffer
			sta PAGE1_LOCATION+$28 + i * $28 ,y
		}
		//set column colors
		.for(var i=0; i<24; i++) {
			lda PAGE0_LOCATION + i * $28 , y
			tax
			lda COLORS, x
			sta $d800 + i * $28 , y
		}
		rts
lbuffer2:

	//Map Column copy
		.for(var i=0; i<24; i++) {
			//Copy nex t column from map
			lda MAP + i * $100, x
			//To relevant column on screen (back 1 char and down q1 char)
			sta PAGE1_LOCATION + i * $28 , y
			//Also to other VIC_buffer
			sta PAGE0_LOCATION+ $28 + i * $28 ,y
		}
		//set column colors
		.for(var i=0; i<24; i++) {
			lda PAGE1_LOCATION + i * $28 , y
			tax
			lda COLORS, x
			sta $d800 + i * $28 , y
		}
		rts	

}


.macro 	_setwi(value,dest) {	
	lda #<value
	sta dest 
	lda #>value 
	sta dest+1
}
.macro _addwi(source,addition,dest) {
	clc 
	lda source 
	adc #<addition
	sta dest 
	lda source+1
	adc #>addition
	sta dest+1
}

//	generate color scroll code 
//	a huge lump of lda $d828 sta $d800 etc. 
ScrollBuild: 
{
	_setwi(ShiftColorRamR,asmdest)
	_setwi($d828,source)
	_setwi($d800,dest)
	ldx #$00 
rloop:

	ldy #$00
lineloop:	
	//	lda $ram 
	lda #$ad
	sta (asmdest),y 
	iny 
	lda source 
	sta (asmdest),y 
	iny 
	lda source+1 
	sta (asmdest),y 
	iny 
	//	sta $ram 
	lda #$8d 
	sta (asmdest),y 
	iny 
	lda dest 
	sta (asmdest),y 
	iny 
	lda dest+1 
	sta (asmdest),y
	iny 

	_addwi(dest,1,dest)
	_addwi(source,1,source) 


	cpy #$ea
	bne lineloop 

	_addwi(asmdest,$ea,asmdest)
	_addwi(dest,1,dest)
	_addwi(source,1,source) 

	inx 
	cpx #24
	beq exitloop
	jmp rloop
exitloop:

	//	rts
	ldy #$00
	lda #$60 
	sta (asmdest),y

	//	left style

	_setwi(ShiftColorRamL,asmdest)
	_setwi($db98,source)
	_setwi($dbc0,dest)

	ldx #$00 
rloop2:

	ldy #$00
lineloop2:	
	//	lda $ram 
	lda #$ad
	sta (asmdest),y 
	iny 
	lda source 
	sta (asmdest),y 
	iny 
	lda source+1 
	sta (asmdest),y 
	iny 
	//	sta $ram 
	lda #$8d 
	sta (asmdest),y 
	iny 
	lda dest 
	sta (asmdest),y 
	iny 
	lda dest+1 
	sta (asmdest),y
	iny 

	_addwi(dest,1,dest)
	_addwi(source,1,source) 


	cpy #$ea
	bne lineloop2 

	_addwi(asmdest,$ea,asmdest)
	_addwi(dest,-79,dest)
	_addwi(source,-79,source) 

	inx 
	cpx #24
	beq exitloop2
	jmp rloop2
exitloop2:

	ldy #$00
	lda #$60 
	sta (asmdest),y

	rts

}

	.align 256
	MAP:
	.import binary "data/mw dragon - Map (8bpc, 256x25).bin"
	.align 256
	COLORS:
	.import binary "data/mw dragon - CharAttribs.bin"

* = $4800
	.import binary "data/mw dragon - Chars.bin"
